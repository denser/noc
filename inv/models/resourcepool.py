# ----------------------------------------------------------------------
# ResourcePool model
# ----------------------------------------------------------------------
# Copyright (C) 2007-2021 The NOC Project
# See LICENSE for details
# ----------------------------------------------------------------------

# Python modules
import operator
import threading
from typing import Optional, List, Callable

# Third-party modules
from mongoengine.document import Document
from mongoengine.fields import StringField, BooleanField, IntField
import cachetools

# NOC Modules
from noc.core.lock.distributed import DistributedLock
from noc.models import get_model

id_lock = threading.Lock()

DISTRIBUTEDLOCK = "resourcepool"
TYPE_RESOURCE_MAP = {"vlan": "vc.VLAN"}


class ResourcePool(Document):
    """
    ResourcePool

    Abstraction to restrict Resources - IP, VLAN
    """

    meta = {
        "collection": "resourcepools",
        "strict": False,
        "auto_create_index": False,
        "indexes": [{"fields": ["type", "api_code"], "unique": True}],
    }

    # Poole name
    name = StringField(unique=True)
    description = StringField()
    # Resource type ?general
    type = StringField(
        choices=[
            ("ip", "IP"),
            ("vlan", "Vlan"),
        ],
        required=True,
    )
    # Only one resource copy in pool
    is_unique = BooleanField(default=False)
    # ?Number ResourceCopy ?
    # How resource allocate
    strategy = StringField(
        choices=[
            ("F", "First"),
            ("L", "Last"),
            ("R", "Random"),
        ],
        default="F",
    )
    # @todo autogenerated
    api_code = StringField(required=True)
    # API Role
    api_role = StringField(default="nbi:allocate")
    # notification_group - ?Notification event
    # Filled warning Threshold
    warn_threshold = IntField(min_value=0, max_value=100, default=0)

    _id_cache = cachetools.TTLCache(maxsize=100, ttl=60)

    def __str__(self):
        return f"{self.type}: {self.name}"

    @classmethod
    @cachetools.cachedmethod(operator.attrgetter("_id_cache"), lock=lambda _: id_lock)
    def get_by_id(cls, id) -> Optional["ResourcePool"]:
        return ResourcePool.objects.filter(id=id).first()

    @classmethod
    def acquire(cls, pools: List["ResourcePool"]):
        """
        # Set Lock
        with ResourcePool.acquire([pool1, ..., poolN]):
            for pool in pools:
                allocator = pool.get_allocator()
                for resource in allocator:
                    resource.
        return

        :param pools:
        :return:
        """
        # generate owner - request_id, BuildFunction
        lock = DistributedLock(DISTRIBUTEDLOCK, "test:12")
        return lock.acquire([str(p.id) for p in pools], ttl=600)

    def get_allocator(self) -> Optional[Callable]:
        if self.type not in TYPE_RESOURCE_MAP:
            raise NotImplementedError(f"Allocator for type {self.type} is NotImplemented")
        model = get_model(TYPE_RESOURCE_MAP[self.type])
        if not hasattr(model, "iter_free"):
            raise NotImplementedError(f"Allocator interface on model {model} NotImpementer")
        return getattr(model, "iter_free")

    @classmethod
    def allocate(cls, pools: List["ResourcePool"], **kwargs):
        r = []
        with ResourcePool.acquire(pools):
            # Set Lock
            for pool in pools:
                allocator = pool.get_allocator()
                for resource in allocator(**kwargs):
                    resource.fire_event("reserve")
                    r += [resource]
        return r

    def check_threshold(self, used: int, total: int) -> bool:
        """
        Check Pool Threshold
        :return:
        """

        used = round(total / used * 100, 2)
        if used > self.warn_threshold:
            # @todo send query
            return False
        return True
